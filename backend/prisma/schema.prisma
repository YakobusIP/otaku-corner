generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [citext]
}

enum ProgressStatus {
  PLANNED
  ON_HOLD
  ON_PROGRESS
  COMPLETED
  DROPPED
}

enum ErrorType {
  WARN
  ERROR
}

enum QueueStatus {
  QUEUED
  COMPLETED
  FAILED
}

model Anime {
  id            String   @id @default(uuid())
  malId         Int      @unique
  type          String
  status        String
  rating        String
  season        String?
  title         String
  titleJapanese String
  titleSynonyms String
  source        String
  aired         String
  broadcast     String
  episodesCount Int?
  duration      String
  score         Float?
  images        Json
  synopsis      String
  trailer       String?
  malUrl        String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  genres   AnimeGenres[]
  studios  AnimeStudios[]
  themes   AnimeThemes[]
  episodes AnimeEpisode[]
  review   AnimeReview    @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  reviewId String         @unique
}

model AnimeEpisode {
  id            String  @id @default(uuid())
  aired         String
  number        Int
  title         String
  titleJapanese String?
  titleRomaji   String?

  anime   Anime  @relation(fields: [animeId], references: [id], onDelete: Cascade)
  animeId String
}

model AnimeReview {
  id                    String         @id @default(uuid())
  review                String?
  storylineRating       Int?
  qualityRating         Int?
  voiceActingRating     Int?
  soundTrackRating      Int?
  charDevelopmentRating Int?
  personalScore         Float?
  progressStatus        ProgressStatus @default(PLANNED)
  consumedAt            DateTime?      @db.Date
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt

  reviewImages ReviewImage[] @relation("AnimeReviewImages")
  anime        Anime?
}

model Manga {
  id            String   @id @default(uuid())
  malId         Int      @unique
  status        String
  title         String
  titleJapanese String
  titleSynonyms String
  published     String
  chaptersCount Int?
  volumesCount  Int?
  score         Float?
  images        Json
  synopsis      String
  malUrl        String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  authors  MangaAuthors[]
  genres   MangaGenres[]
  themes   MangaThemes[]
  review   MangaReview    @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  reviewId String         @unique
}

model MangaReview {
  id                    String         @id @default(uuid())
  review                String?
  storylineRating       Int?
  artStyleRating        Int?
  charDevelopmentRating Int?
  worldBuildingRating   Int?
  originalityRating     Int?
  personalScore         Float?
  progressStatus        ProgressStatus @default(PLANNED)
  consumedAt            DateTime?      @db.Date
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt

  reviewImages ReviewImage[] @relation("MangaReviewImages")
  manga        Manga?
}

model LightNovel {
  id            String   @id @default(uuid())
  malId         Int      @unique
  status        String
  title         String
  titleJapanese String
  titleSynonyms String
  published     String
  volumesCount  Int?
  score         Float?
  images        Json
  synopsis      String
  malUrl        String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  authors        LightNovelAuthors[]
  genres         LightNovelGenres[]
  themes         LightNovelThemes[]
  volumeProgress LightNovelVolumes[]
  review         LightNovelReview    @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  reviewId       String              @unique
}

model LightNovelReview {
  id                    String         @id @default(uuid())
  review                String?
  storylineRating       Int?
  worldBuildingRating   Int?
  writingStyleRating    Int?
  charDevelopmentRating Int?
  originalityRating     Int?
  personalScore         Float?
  progressStatus        ProgressStatus @default(PLANNED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reviewImages ReviewImage[] @relation("LightNovelReviewImages")
  lightNovel   LightNovel?
}

model LightNovelVolumes {
  id           String     @id @default(uuid())
  volumeNumber Int
  consumedAt   DateTime?  @db.Date
  lightNovel   LightNovel @relation(fields: [lightNovelId], references: [id], onDelete: Cascade)
  lightNovelId String

  @@unique([volumeNumber, lightNovelId])
}

model Genre {
  id          String             @id @default(uuid())
  name        String             @unique @db.Citext
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  animes      AnimeGenres[]
  mangas      MangaGenres[]
  lightNovels LightNovelGenres[]
}

model Studio {
  id        String         @id @default(uuid())
  name      String         @unique @db.Citext
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  animes    AnimeStudios[]
}

model Theme {
  id          String             @id @default(uuid())
  name        String             @unique @db.Citext
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  animes      AnimeThemes[]
  mangas      MangaThemes[]
  lightNovels LightNovelThemes[]
}

model Author {
  id          String              @id @default(uuid())
  name        String              @unique @db.Citext
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  mangas      MangaAuthors[]
  lightNovels LightNovelAuthors[]
}

model AnimeGenres {
  anime   Anime  @relation(fields: [animeId], references: [id], onDelete: Cascade)
  animeId String
  genre   Genre  @relation(fields: [genreId], references: [id], onDelete: Cascade)
  genreId String

  @@id([animeId, genreId])
}

model MangaGenres {
  manga   Manga  @relation(fields: [mangaId], references: [id], onDelete: Cascade)
  mangaId String
  genre   Genre  @relation(fields: [genreId], references: [id], onDelete: Cascade)
  genreId String

  @@id([mangaId, genreId])
}

model LightNovelGenres {
  lightNovel   LightNovel @relation(fields: [lightNovelId], references: [id], onDelete: Cascade)
  lightNovelId String
  genre        Genre      @relation(fields: [genreId], references: [id], onDelete: Cascade)
  genreId      String

  @@id([lightNovelId, genreId])
}

model AnimeStudios {
  anime    Anime  @relation(fields: [animeId], references: [id], onDelete: Cascade)
  animeId  String
  studio   Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)
  studioId String

  @@id([animeId, studioId])
}

model AnimeThemes {
  anime   Anime  @relation(fields: [animeId], references: [id], onDelete: Cascade)
  animeId String
  theme   Theme  @relation(fields: [themeId], references: [id], onDelete: Cascade)
  themeId String

  @@id([animeId, themeId])
}

model MangaThemes {
  manga   Manga  @relation(fields: [mangaId], references: [id], onDelete: Cascade)
  mangaId String
  theme   Theme  @relation(fields: [themeId], references: [id], onDelete: Cascade)
  themeId String

  @@id([mangaId, themeId])
}

model LightNovelThemes {
  lightNovel   LightNovel @relation(fields: [lightNovelId], references: [id], onDelete: Cascade)
  lightNovelId String
  theme        Theme      @relation(fields: [themeId], references: [id], onDelete: Cascade)
  themeId      String

  @@id([lightNovelId, themeId])
}

model MangaAuthors {
  manga    Manga  @relation(fields: [mangaId], references: [id], onDelete: Cascade)
  mangaId  String
  author   Author @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId String

  @@id([mangaId, authorId])
}

model LightNovelAuthors {
  lightNovel   LightNovel @relation(fields: [lightNovelId], references: [id], onDelete: Cascade)
  lightNovelId String
  author       Author     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId     String

  @@id([lightNovelId, authorId])
}

model AdminPin {
  id        String   @id @default(uuid())
  pin1      String
  pin2      String
  createdAt DateTime @default(now())
}

model ReviewImage {
  id        String   @id @default(uuid())
  url       String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  animeReview   AnimeReview? @relation("AnimeReviewImages", fields: [animeReviewId], references: [id], onDelete: Cascade)
  animeReviewId String?

  mangaReview   MangaReview? @relation("MangaReviewImages", fields: [mangaReviewId], references: [id], onDelete: Cascade)
  mangaReviewId String?

  lightNovelReview   LightNovelReview? @relation("LightNovelReviewImages", fields: [lightNovelReviewId], references: [id], onDelete: Cascade)
  lightNovelReviewId String?
}

model RequestLog {
  id        String   @id @default(uuid())
  hostname  String
  ip        String?
  method    String
  url       String
  headers   Json
  body      Json
  status    Int
  response  Json?
  timestamp DateTime @default(now())
}

model ErrorLog {
  id         String    @id @default(uuid())
  message    String
  type       ErrorType
  statusCode Int?
  stack      String?
  route      String
  timestamp  DateTime  @default(now())
}

model QueueLog {
  id          String      @id @default(uuid())
  jobId       String      @unique
  queueName   String
  status      QueueStatus
  data        Json
  result      Json?
  error       String?
  timestamp   DateTime    @default(now())
  completedAt DateTime?
}
